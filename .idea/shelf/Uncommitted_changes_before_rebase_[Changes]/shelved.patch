Index: app/src/main/java/com/seventeen/edtinp/MainActivity.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.seventeen.edtinp\r\n\r\n\r\nimport android.annotation.SuppressLint\r\nimport android.app.Activity\r\nimport android.app.AlertDialog\r\nimport android.content.Context\r\nimport android.content.DialogInterface\r\nimport android.graphics.Bitmap\r\nimport android.graphics.Color.rgb\r\nimport android.graphics.drawable.Drawable\r\nimport android.os.Bundle\r\nimport android.os.Handler\r\nimport android.os.Looper\r\nimport android.util.DisplayMetrics\r\nimport android.util.Log\r\nimport android.view.Menu\r\nimport android.view.MenuItem\r\nimport android.view.View\r\nimport android.webkit.JavascriptInterface\r\nimport android.webkit.WebView\r\nimport android.webkit.WebViewClient\r\nimport android.widget.Button\r\nimport android.widget.ImageView\r\nimport android.widget.TextView\r\nimport android.widget.Toast\r\nimport androidx.appcompat.app.AppCompatActivity\r\nimport androidx.core.content.ContextCompat\r\nimport androidx.core.view.children\r\nimport androidx.fragment.app.FragmentActivity\r\nimport kotlinx.coroutines.*\r\nimport java.io.IOException\r\nimport java.util.Calendar\r\nimport java.util.concurrent.Executors\r\nimport kotlin.concurrent.thread\r\n\r\n\r\nclass MainActivity : AppCompatActivity(), DatePicker.OnDatePass {\r\n    @SuppressLint(\"SetJavaScriptEnabled\")\r\n    lateinit var backgroundWebView: WebView\r\n\r\n    val mainUrl = \"https://edt.grenoble-inp.fr/2023-2024/exterieur\"\r\n\r\n    val jsSetReferenceDelay = 1000\r\n\r\n    @SuppressLint(\"SetJavaScriptEnabled\")\r\n    override fun onCreate(savedInstanceState: Bundle?) {\r\n        super.onCreate(savedInstanceState)\r\n        setContentView(R.layout.activity_main)\r\n\r\n        // Ajoute la barre d'outil supérieure\r\n        setSupportActionBar(findViewById(R.id.toolbar))\r\n\r\n        // Initialisation des paramètres de la classe ImageHandler, qui est chargée de l'affichage de l'edt\r\n        val imageView: ImageView = findViewById(R.id.imageView)\r\n        val myExecutor = Executors.newSingleThreadExecutor()\r\n        val myHandler = Handler(Looper.getMainLooper())\r\n        dataHandler = DataHandler(this) // Initialise le gestionnaire de données\r\n        val cacheHandler: CacheHandler = CacheHandler(this, dataHandler)\r\n        // Initialisation de ImageHandler, cet objet n'est créé qu'une seule fois dans l'Activité\r\n        val imageHandler = ImageHandler(this, imageView, myExecutor, myHandler, cacheHandler)\r\n\r\n        // Initialisation de la WebView d'arrière plan nécessaire pour générer des images à la taille de l'écran\r\n        backgroundWebView = findViewById(R.id.backgroundWebView)\r\n        backgroundWebView.settings.javaScriptEnabled = true\r\n        backgroundWebView.addJavascriptInterface(\r\n            WebViewJavaScriptInterface(\r\n                this,\r\n                backgroundWebView,\r\n                imageHandler\r\n            ), \"app\"\r\n        )\r\n        backgroundWebView.visibility = View.INVISIBLE\r\n\r\n\r\n        // Initialisation du calendrier de sélection de date\r\n        val dateButton = findViewById<ImageView>(R.id.calendar_button)\r\n        dateButton.setOnClickListener {\r\n            val datePicker =\r\n                DatePicker(imageHandler)\r\n            datePicker.show(supportFragmentManager, DatePicker.TAG)\r\n        }\r\n\r\n        val refreshButton = findViewById<ImageView>(R.id.refresh_button)\r\n        refreshButton.setOnClickListener {\r\n            imageHandler.updateImage(true)\r\n        }\r\n        refreshButton.isEnabled = false\r\n        refreshButton.setColorFilter(rgb(184, 184, 184))\r\n\r\n\r\n\r\n        // On agrandit la taille du webView pour optimiser l'affichage\r\n        // Nécessaire pour générer une image de la bonne taille\r\n        val displayMetrics = DisplayMetrics()\r\n        @Suppress(\"DEPRECATION\")\r\n        windowManager.defaultDisplay.getMetrics(displayMetrics)\r\n        val width = displayMetrics.widthPixels\r\n        Log.d(\r\n            \"WebViewHandler\",\r\n            \"Gained pixels: ${width * 18 / 100}\"\r\n        ) // 18% : taille trouvée dans le html\r\n        backgroundWebView.layoutParams.width = width + width * 18 / 100 + 25\r\n\r\n        // Obtention de l'id de la semaine actuelle\r\n        val calendar = Calendar.getInstance()\r\n        var currentWeekNumber = calendar.get(Calendar.WEEK_OF_YEAR)\r\n        if ((calendar.get(Calendar.DAY_OF_WEEK) == Calendar.SATURDAY) or (calendar.get(Calendar.DAY_OF_WEEK) == Calendar.SUNDAY)) {\r\n            currentWeekNumber += 1\r\n        }\r\n        val currentWeekId: Int = if (currentWeekNumber < 32) {\r\n            currentWeekNumber + 20\r\n        } else {\r\n            currentWeekNumber - 32\r\n        }\r\n        displayedWeekId = currentWeekId\r\n\r\n\r\n        DataHandler.data.currentWeekId = currentWeekId\r\n        DataHandler.data.currentDayOfWeek = calendar.get(Calendar.DAY_OF_WEEK) - 1\r\n        dataHandler.updateSave()\r\n\r\n        Log.v(\"Date Handler\", \"Week number is $currentWeekNumber week id is $currentWeekId\")\r\n\r\n\r\n        Log.v(\"hello\", \"today ${calendar.get(Calendar.DAY_OF_WEEK)}\")\r\n        val imageBitmap = cacheHandler.getImage(\"week${displayedWeekId}\")\r\n        if (imageBitmap != null) {\r\n            imageView.setImageBitmap(imageBitmap)\r\n        }\r\n\r\n\r\n        // Client WebView d'arrière-plan\r\n        backgroundWebView.webViewClient = object : WebViewClient() {\r\n            var isRedirected = false\r\n\r\n            override fun onPageStarted(view: WebView?, url: String?, favicon: Bitmap?) {\r\n                if (!isRedirected) {\r\n                    Log.v(\"URL_Loader\", \"Loading $url\")\r\n                }\r\n                isRedirected = false\r\n            }\r\n\r\n            @Deprecated(\"Ignore\")\r\n            override fun shouldOverrideUrlLoading(view: WebView, url: String?): Boolean {\r\n                view.loadUrl(url!!)\r\n                isRedirected = true\r\n                return true\r\n            }\r\n\r\n            override fun onPageFinished(view: WebView?, url: String) {\r\n                super.onPageFinished(view, url)\r\n                if (isRedirected) {\r\n                    Log.v(\"URL_Loader\", \"Redirected from $url\")\r\n                }\r\n\r\n                // Mise en page du contenu\r\n                if (url != mainUrl) {\r\n                    Log.v(\"URL_Loader\", \"Loading page\")\r\n                    var search = \"\"\r\n                    when (DataHandler.data.classe) {\r\n                        \"1A-PINP\" -> search = search1A\r\n                        \"2A-PINP\" -> search = search2A\r\n                        \"HN1-PINP\" -> search = searchHN1\r\n                        \"HN2-PINP\" -> search = searchHN2\r\n                        \"HN3-PINP\" -> search = searchHN3\r\n                    }\r\n                    val jsCode =\r\n                        (preload + search + load)\r\n                    backgroundWebView.evaluateJavascript(jsCode, null)\r\n\r\n                    // Vérification de la semaine affichée\r\n                    backgroundWebView.evaluateJavascript(get_selected_week) {\r\n                        var cacheWeekNumber: String // Prend la valeur retournée par le code javascript\r\n                        if ((it == \"null\") or (it.length < 5)) {\r\n                            Log.d(\"Preloader\", \"Got null resource\")\r\n                        } else {\r\n                            cacheWeekNumber = it.subSequence(2, 4).toString()\r\n                            if (cacheWeekNumber[0].toString() == \" \") {\r\n                                cacheWeekNumber = cacheWeekNumber[0].toString()\r\n                            }\r\n                            if (cacheWeekNumber.toInt() != currentWeekNumber) {\r\n                                Log.d(\"Preloader\", \"Found cached week, reloading to $currentWeekId\")\r\n                                //TODO push nécessaire ? Est-il possible de juste recharger au jour J ?\r\n                                backgroundWebView.evaluateJavascript(\r\n                                    js_functions + \"push($displayedWeekId, true);\",\r\n                                    null\r\n                                )\r\n                            }\r\n\r\n\r\n                            //TODO délais\r\n\r\n                            // Initialise les objets de la classe\r\n                            backgroundWebView.evaluateJavascript(\r\n                                \"setTimeout(function() {$set_reference_url}, $jsSetReferenceDelay)\",\r\n                                null\r\n                            )\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n\r\n        // Initialisation des boutons de navigation\r\n        val prevButton = findViewById<Button>(R.id.prev_week)\r\n        prevButton.isEnabled = false\r\n        val nextButton = findViewById<Button>(R.id.next_week)\r\n        nextButton.isEnabled = false\r\n\r\n        //TODO désactiver les boutons par défaut et les activer lorsque la page est affichée ?\r\n\r\n        prevButton.setOnClickListener {\r\n            backgroundWebView.evaluateJavascript(check_edt_availability) {// Nécessaire pour invalider le clic si page non chargée\r\n                if (it != \"null\") {\r\n                    val result =\r\n                        it.toInt() // Taille de la recherche du tag img dans la fenêtre, 1 si edt visible, 0 sinon\r\n\r\n                    // Incrémentation de l'id de la semaine\r\n                    if ((displayedWeekId > 0) and (result != 0)) { // result == 0 => edt non visible\r\n                        displayedWeekId -= 1\r\n                        Log.v(\"Date Handler\", \"Moving to week $displayedWeekId\")\r\n                        // Met l'image dans une ImageView\r\n                        imageHandler.updateImage()\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        nextButton.setOnClickListener {\r\n            backgroundWebView.evaluateJavascript(check_edt_availability) {// Nécessaire pour invalider le clic si page non chargée\r\n                if (it != \"null\") {\r\n                    val result =\r\n                        it.toInt() // Taille de la recherche du tag img dans la fenêtre, 1 si edt visible, 0 sinon\r\n\r\n                    // Incrémentation de l'id de la semaine\r\n                    if ((displayedWeekId < 51) and (result != 0)) { // Result == 0 => edt non visible\r\n                        displayedWeekId += 1\r\n                        Log.v(\"Date Handler\", \"Moving to week $displayedWeekId\")\r\n                        // Met à jour l'image\r\n                        imageHandler.updateImage()\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        thread {\r\n            if (isOnline()) {\r\n                this.runOnUiThread {\r\n                    // Charge la WebView d'arrère-plan\r\n                    backgroundWebView.loadUrl(mainUrl)\r\n                }\r\n            } else {\r\n                this.runOnUiThread {\r\n                    AlertDialog.Builder(this)\r\n                        .setTitle(\"Pas de connexion internet\")\r\n                        .setMessage(\"Vous pouvez quand même consulter la semaine actuelle, fermer l'application ?\") // Specifying a listener allows you to take an action before dismissing the dialog.\r\n                        // The dialog is automatically dismissed when a dialog button is clicked.\r\n                        .setPositiveButton(\"Fermer\",\r\n                            DialogInterface.OnClickListener { dialog, _ ->\r\n                                dialog.dismiss(); finishAndRemoveTask()\r\n                            }) // A null listener allows the button to dismiss the dialog and take no further action.\r\n                        .setNegativeButton(\"Rester\") { dialog, _ ->\r\n                            dialog.dismiss()\r\n                            prevButton.isEnabled = false\r\n                            nextButton.isEnabled = false\r\n                            isNavigationRestricted = true\r\n                        }\r\n                        .show()\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    /** sauvegarde la nouvelle classe */\r\n    private fun changeClasse(classe: String) {\r\n\r\n        DataHandler.data.classe = classe\r\n        dataHandler.updateSave()\r\n    }\r\n\r\n    fun isOnline(): Boolean {\r\n        val runtime = Runtime.getRuntime()\r\n        try {\r\n            val ipProcess = runtime.exec(\"/system/bin/ping -c 1 8.8.8.8\")\r\n            val exitValue = ipProcess.waitFor()\r\n            return exitValue == 0\r\n        } catch (e: IOException) {\r\n            e.printStackTrace()\r\n        } catch (e: InterruptedException) {\r\n            e.printStackTrace()\r\n        }\r\n        return false\r\n    }\r\n\r\n    /** Initialise le menu en haut à gauche en ajoutant le nom de l'appli à côté */\r\n    override fun onCreateOptionsMenu(menu: Menu): Boolean {\r\n        val hamButton: Drawable? = ContextCompat.getDrawable(this, R.drawable.ic_baseline_menu_24)\r\n        val toolbar: androidx.appcompat.widget.Toolbar = findViewById(R.id.toolbar)\r\n\r\n        // Met l'icône de menu en tant que bouton de navigation\r\n//        toolbar.navigationIcon = hamButton\r\n\r\n        menuInflater.inflate(R.menu.menu, menu)\r\n        val classeTextView = findViewById<TextView>(R.id.classe_tv)\r\n        classeTextView.text = DataHandler.data.classe\r\n        return true\r\n    }\r\n\r\n    override fun onPrepareOptionsMenu(menu: Menu?): Boolean {\r\n        if (isNavigationRestricted) {\r\n            for (item in menu!!.children) {\r\n                item.isEnabled = false\r\n            }\r\n        } else {\r\n            for (item in menu!!.children) {\r\n                item.isEnabled = true\r\n            }\r\n        }\r\n        return true\r\n    }\r\n\r\n    /** Fonction appelée lorsque l'utilisateur effectue un clic sur un jour du calendrier\r\n     * Met à jour l'objet selectedWeekId\r\n     * @param weekId Id de la semaine à stocker dans l'objet selectedWeekId */\r\n    override fun onDatePass(weekId: Int, activity: FragmentActivity?) {\r\n        Log.v(\"TempSave\", \"Updated to $weekId\")\r\n        selectedWeekId = weekId\r\n    }\r\n\r\n\r\n    override fun onOptionsItemSelected(item: MenuItem): Boolean {\r\n        /** Callback lors d'un clic dans le menu de sélection de classe en haut à droite  */\r\n        var search = \"\"\r\n        when (item.title) {\r\n            getString(R.string.A1) -> {\r\n                changeClasse(\"1A-PINP\")\r\n                Log.v(\"Menu Handler\", DataHandler.data.classe)\r\n                search = search1A\r\n            }\r\n\r\n            getString(R.string.A2) -> {\r\n                changeClasse(\"2A-PINP\")\r\n                Log.v(\"Menu Handler\", DataHandler.data.classe)\r\n                search = search2A\r\n            }\r\n\r\n            getString(R.string.HN1) -> {\r\n                changeClasse(\"HN1-PINP\")\r\n                Log.v(\"Menu Handler\", DataHandler.data.classe)\r\n                search = searchHN1\r\n            }\r\n\r\n            getString(R.string.HN2) -> {\r\n                changeClasse(\"HN2-PINP\")\r\n                Log.v(\"Menu Handler\", DataHandler.data.classe)\r\n                search = searchHN2\r\n            }\r\n\r\n            getString(R.string.HN3) -> {\r\n                changeClasse(\"HN3-PINP\")\r\n                Log.v(\"Menu Handler\", DataHandler.data.classe)\r\n                search = searchHN3\r\n            }\r\n        }\r\n\r\n        // Met le nom de la class à jour\r\n        val classeTextView = findViewById<TextView>(R.id.classe_tv)\r\n        classeTextView.text = DataHandler.data.classe\r\n\r\n        // En cas de besoin, choisir une classe recharge la page (permet de sortir d'un bug)\r\n        backgroundWebView.evaluateJavascript(get_selected_week) {\r\n            if ((it == \"null\") or (it.length < 5)) {\r\n                // Cas du bug\r\n                Log.d(\"Preloader\", \"Got null resource\"); backgroundWebView.loadUrl(mainUrl)\r\n            } else {\r\n                // Si la classe est changée, alors on remet à jour la page\r\n                Log.v(\"DEBUG\", \"reload\")\r\n                backgroundWebView.evaluateJavascript(preload + search + load, null)\r\n                backgroundWebView.evaluateJavascript(\r\n                    js_functions + \"push($displayedWeekId, true)\",\r\n                    null\r\n                )\r\n\r\n                // Initialise les objets de la classe\r\n                backgroundWebView.evaluateJavascript(\r\n                    \"setTimeout(function() {$set_reference_url}, $jsSetReferenceDelay)\",\r\n                    null\r\n                )\r\n            }\r\n        }\r\n        return super.onOptionsItemSelected(item)\r\n    }\r\n\r\n    /*\r\n     * JavaScript Interface. Web code can access methods in here\r\n     * (as long as they have the @JavascriptInterface annotation)\r\n     */\r\n    /**\r\n     * @param backgroundWebView WebView de référence (en arrière-plan)\r\n     * @param imageHandler ImageHandler responsable du chargement de l'image\r\n     */\r\n    class WebViewJavaScriptInterface    /*\r\n        * Need a reference to the context in order to sent a post message\r\n        */(\r\n        private val context: Context,\r\n        private val backgroundWebView: WebView,\r\n        private val imageHandler: ImageHandler\r\n    ) {\r\n\r\n        @JavascriptInterface\r\n                /*\r\n                * This method can be called from Android. @JavascriptInterface\r\n                * required after SDK version 17.\r\n                */\r\n        fun makeToast(message: String?, lengthLong: Boolean = true) {\r\n            Toast.makeText(\r\n                context,\r\n                message,\r\n                if (lengthLong) Toast.LENGTH_LONG else Toast.LENGTH_SHORT\r\n            ).show()\r\n        }\r\n\r\n        /** Met à jour les objets de l'activité et affiche l'image avec la nouvelle référence\r\n         * Objets mis à jour :  referenceUrl; idSemaineUrl\r\n         * Cette méthode est appelée lorsque l'on change de classe ou lors du lancement de l'application */\r\n        @JavascriptInterface\r\n        fun setReferenceUrl(url: String) {\r\n            //TODO boucle infinie\r\n            if (url == \"\") {\r\n                backgroundWebView.post {\r\n                    backgroundWebView.evaluateJavascript(\r\n                        set_reference_url,\r\n                        null\r\n                    )\r\n                }; return\r\n            } else {\r\n                referenceURL = url\r\n\r\n\r\n                // Met à jour l'objet id de la semaine\r\n                val splitUrl = referenceURL.split(\"&\") as MutableList\r\n                var i = 0\r\n                for (item in splitUrl) {\r\n                    if (item.split(\"=\").size == 2) {\r\n                        if (item.split(\"=\")[0] == \"idPianoWeek\") {\r\n                            idSemaineUrl = i\r\n                        }\r\n                    }\r\n                    i += 1\r\n                }\r\n\r\n                // Crée le lien vers l'image\r\n                val spliturl = referenceURL.split(\"&\") as MutableList\r\n                spliturl[idSemaineUrl + 1] = \"idPianoDay=0%2C1%2C2%2C3%2C4\"\r\n                referenceURL = spliturl.joinToString(\"&\")\r\n\r\n                Log.v(\r\n                    \"ImageHandler\",\r\n                    \"Reference url set to $referenceURL and week id set to $idSemaineUrl\"\r\n                )\r\n                makeToast(\"Connection établie\", false)\r\n\r\n                isNavigationRestricted = false\r\n                val prevButton = (context as Activity).findViewById<Button>(R.id.prev_week)\r\n                val nextButton = context.findViewById<Button>(R.id.next_week)\r\n                val loadingTv = context.findViewById<TextView>(R.id.loading_tv)\r\n                val refreshButton = context.findViewById<ImageView>(R.id.refresh_button)\r\n                context.runOnUiThread {\r\n                    prevButton.isEnabled = true\r\n                    nextButton.isEnabled = true\r\n                    refreshButton.isEnabled = true\r\n                    refreshButton.setColorFilter(rgb(255, 255, 255))\r\n                    loadingTv.visibility = View.INVISIBLE\r\n                }\r\n\r\n                // Affiche l'image de référence\r\n                imageHandler.updateImage()\r\n            }\r\n        }\r\n\r\n        /** Fonction appelée en cas d'échec lors de la récupération du lien de référence de l'image */\r\n        @JavascriptInterface\r\n        fun onLoadingFail() {\r\n            makeToast(\"Chargement échoué\")\r\n        }\r\n    }\r\n\r\n    companion object {\r\n        var referenceURL: String = \"\"\r\n        var idSemaineUrl: Int = 0\r\n        var selectedWeekId: Int = 0\r\n        var displayedWeekId: Int = 0\r\n        lateinit var dataHandler: DataHandler\r\n        var isNavigationRestricted: Boolean = true\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/seventeen/edtinp/MainActivity.kt b/app/src/main/java/com/seventeen/edtinp/MainActivity.kt
--- a/app/src/main/java/com/seventeen/edtinp/MainActivity.kt	(revision 841cbd270692e21f649c78520020a7385fb5c8a7)
+++ b/app/src/main/java/com/seventeen/edtinp/MainActivity.kt	(date 1695480471908)
@@ -43,6 +43,8 @@
 
     val jsSetReferenceDelay = 1000
 
+    private lateinit var dataHandler: DataHandler
+
     @SuppressLint("SetJavaScriptEnabled")
     override fun onCreate(savedInstanceState: Bundle?) {
         super.onCreate(savedInstanceState)
@@ -56,7 +58,7 @@
         val myExecutor = Executors.newSingleThreadExecutor()
         val myHandler = Handler(Looper.getMainLooper())
         dataHandler = DataHandler(this) // Initialise le gestionnaire de données
-        val cacheHandler: CacheHandler = CacheHandler(this, dataHandler)
+        val cacheHandler = CacheHandler(this, dataHandler)
         // Initialisation de ImageHandler, cet objet n'est créé qu'une seule fois dans l'Activité
         val imageHandler = ImageHandler(this, imageView, myExecutor, myHandler, cacheHandler)
 
@@ -81,12 +83,13 @@
             datePicker.show(supportFragmentManager, DatePicker.TAG)
         }
 
+        // Initialisation du bouton de rafraîchissement
         val refreshButton = findViewById<ImageView>(R.id.refresh_button)
         refreshButton.setOnClickListener {
             imageHandler.updateImage(true)
         }
         refreshButton.isEnabled = false
-        refreshButton.setColorFilter(rgb(184, 184, 184))
+        refreshButton.setColorFilter(rgb(184, 184, 184)) // Filtre gris tant que la connexion n'est pas établie
 
 
 
@@ -115,15 +118,14 @@
         }
         displayedWeekId = currentWeekId
 
-
+        // Mise à jour des données
         DataHandler.data.currentWeekId = currentWeekId
         DataHandler.data.currentDayOfWeek = calendar.get(Calendar.DAY_OF_WEEK) - 1
         dataHandler.updateSave()
 
         Log.v("Date Handler", "Week number is $currentWeekNumber week id is $currentWeekId")
 
-
-        Log.v("hello", "today ${calendar.get(Calendar.DAY_OF_WEEK)}")
+        // Affiche l'image de la semaine gardée en cache
         val imageBitmap = cacheHandler.getImage("week${displayedWeekId}")
         if (imageBitmap != null) {
             imageView.setImageBitmap(imageBitmap)
@@ -180,7 +182,7 @@
                                 cacheWeekNumber = cacheWeekNumber[0].toString()
                             }
                             if (cacheWeekNumber.toInt() != currentWeekNumber) {
-                                Log.d("Preloader", "Found cached week, reloading to $currentWeekId")
+                                Log.d("Preloader", "Found wrong week, reloading to $currentWeekId")
                                 //TODO push nécessaire ? Est-il possible de juste recharger au jour J ?
                                 backgroundWebView.evaluateJavascript(
                                     js_functions + "push($displayedWeekId, true);",
@@ -193,9 +195,7 @@
 
                             // Initialise les objets de la classe
                             backgroundWebView.evaluateJavascript(
-                                "setTimeout(function() {$set_reference_url}, $jsSetReferenceDelay)",
-                                null
-                            )
+                                "setTimeout(function() {$set_reference_url}, $jsSetReferenceDelay)", null)
                         }
                     }
                 }
@@ -209,8 +209,6 @@
         val nextButton = findViewById<Button>(R.id.next_week)
         nextButton.isEnabled = false
 
-        //TODO désactiver les boutons par défaut et les activer lorsque la page est affichée ?
-
         prevButton.setOnClickListener {
             backgroundWebView.evaluateJavascript(check_edt_availability) {// Nécessaire pour invalider le clic si page non chargée
                 if (it != "null") {
@@ -244,6 +242,7 @@
             }
         }
 
+        // Vérification de la connectivité à internet
         thread {
             if (isOnline()) {
                 this.runOnUiThread {
@@ -251,15 +250,15 @@
                     backgroundWebView.loadUrl(mainUrl)
                 }
             } else {
+                // Affiche un dialogue et propose de rester en mode hors ligne
+                //TODO ajouter une checkbox pour ne plus afficher le dialogue
                 this.runOnUiThread {
                     AlertDialog.Builder(this)
                         .setTitle("Pas de connexion internet")
-                        .setMessage("Vous pouvez quand même consulter la semaine actuelle, fermer l'application ?") // Specifying a listener allows you to take an action before dismissing the dialog.
-                        // The dialog is automatically dismissed when a dialog button is clicked.
-                        .setPositiveButton("Fermer",
-                            DialogInterface.OnClickListener { dialog, _ ->
-                                dialog.dismiss(); finishAndRemoveTask()
-                            }) // A null listener allows the button to dismiss the dialog and take no further action.
+                        .setMessage("Vous pouvez quand même consulter la semaine actuelle, fermer l'application ?")
+                        .setPositiveButton("Fermer") { dialog, _ ->
+                            dialog.dismiss(); finishAndRemoveTask()
+                        }
                         .setNegativeButton("Rester") { dialog, _ ->
                             dialog.dismiss()
                             prevButton.isEnabled = false
@@ -273,14 +272,16 @@
     }
 
 
-    /** sauvegarde la nouvelle classe */
+    /** Sauvegarde la nouvelle classe */
     private fun changeClasse(classe: String) {
-
         DataHandler.data.classe = classe
         dataHandler.updateSave()
     }
 
-    fun isOnline(): Boolean {
+    /** Essaie une transaction internet
+     * @return true si connexion à internet, et false sinon
+     */
+    private fun isOnline(): Boolean {
         val runtime = Runtime.getRuntime()
         try {
             val ipProcess = runtime.exec("/system/bin/ping -c 1 8.8.8.8")
@@ -307,7 +308,7 @@
         classeTextView.text = DataHandler.data.classe
         return true
     }
-
+    /** Active ou désactive les champs de sélection en fonction de l'objet isNavigationRestricted */
     override fun onPrepareOptionsMenu(menu: Menu?): Boolean {
         if (isNavigationRestricted) {
             for (item in menu!!.children) {
@@ -329,7 +330,7 @@
         selectedWeekId = weekId
     }
 
-
+    /** Callback lors d'un clic dans le menu de sélection de classe en haut à droite  */
     override fun onOptionsItemSelected(item: MenuItem): Boolean {
         /** Callback lors d'un clic dans le menu de sélection de classe en haut à droite  */
         var search = ""
@@ -384,10 +385,7 @@
                 )
 
                 // Initialise les objets de la classe
-                backgroundWebView.evaluateJavascript(
-                    "setTimeout(function() {$set_reference_url}, $jsSetReferenceDelay)",
-                    null
-                )
+                backgroundWebView.evaluateJavascript("setTimeout(function() {$set_reference_url}, $jsSetReferenceDelay)", null)
             }
         }
         return super.onOptionsItemSelected(item)
@@ -429,12 +427,7 @@
         fun setReferenceUrl(url: String) {
             //TODO boucle infinie
             if (url == "") {
-                backgroundWebView.post {
-                    backgroundWebView.evaluateJavascript(
-                        set_reference_url,
-                        null
-                    )
-                }; return
+                makeToast("Erreur lors de la récupération du lien"); return
             } else {
                 referenceURL = url
 
@@ -456,12 +449,11 @@
                 spliturl[idSemaineUrl + 1] = "idPianoDay=0%2C1%2C2%2C3%2C4"
                 referenceURL = spliturl.joinToString("&")
 
-                Log.v(
-                    "ImageHandler",
-                    "Reference url set to $referenceURL and week id set to $idSemaineUrl"
-                )
+                Log.v("ImageHandler", "Reference url set to $referenceURL and week id set to $idSemaineUrl")
                 makeToast("Connection établie", false)
 
+
+                // Active tous les widgets de navigation
                 isNavigationRestricted = false
                 val prevButton = (context as Activity).findViewById<Button>(R.id.prev_week)
                 val nextButton = context.findViewById<Button>(R.id.next_week)
@@ -472,10 +464,10 @@
                     nextButton.isEnabled = true
                     refreshButton.isEnabled = true
                     refreshButton.setColorFilter(rgb(255, 255, 255))
-                    loadingTv.visibility = View.INVISIBLE
+                    loadingTv.visibility = View.GONE
                 }
 
-                // Affiche l'image de référence
+                // Affiche l'image de référence mise à jour
                 imageHandler.updateImage()
             }
         }
@@ -492,7 +484,6 @@
         var idSemaineUrl: Int = 0
         var selectedWeekId: Int = 0
         var displayedWeekId: Int = 0
-        lateinit var dataHandler: DataHandler
         var isNavigationRestricted: Boolean = true
     }
 }
\ No newline at end of file
Index: app/src/main/java/com/seventeen/edtinp/ImageHandler.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.seventeen.edtinp\r\n\r\nimport android.content.ContentValues\r\nimport android.content.Context\r\nimport android.graphics.Bitmap\r\nimport android.graphics.BitmapFactory\r\nimport android.net.Uri\r\nimport android.os.Build\r\nimport android.os.Environment\r\nimport android.os.Handler\r\nimport android.provider.MediaStore\r\nimport android.util.Log\r\nimport android.util.LruCache\r\nimport android.widget.ImageView\r\nimport android.widget.Toast\r\nimport java.io.BufferedInputStream\r\nimport java.io.File\r\nimport java.io.FileOutputStream\r\nimport java.io.IOException\r\nimport java.io.InputStream\r\nimport java.io.OutputStream\r\nimport java.net.HttpURLConnection\r\nimport java.net.MalformedURLException\r\nimport java.net.URL\r\nimport java.util.concurrent.ExecutorService\r\n\r\n\r\n/** Gestionnaire de l'affichage de l'image de l'emploi du temps\r\n * @param imageView ImageView qui doit afficher l'image\r\n */\r\nclass ImageHandler\r\n    (\r\n    private val context: Context,\r\n    private val imageView: ImageView,\r\n    private val executor: ExecutorService,\r\n    private val handler: Handler,\r\n    private val cacheHandler: CacheHandler\r\n) {\r\n    private var memoryCache: LruCache<String, Bitmap>\r\n\r\n\r\n    init {\r\n        // Get max available VM memory, exceeding this amount will throw an\r\n        // OutOfMemory exception. Stored in kilobytes as LruCache takes an\r\n        // int in its constructor.\r\n        val maxMemory = (Runtime.getRuntime().maxMemory() / 1024).toInt()\r\n\r\n//        Log.d(\"CacheHandler\", File(context.cacheDir, \"\"))\r\n\r\n        // Use 1/8th of the available memory for this memory cache.\r\n        val cacheSize = maxMemory / 8\r\n\r\n        memoryCache = object : LruCache<String, Bitmap>(cacheSize) {\r\n\r\n            override fun sizeOf(key: String, bitmap: Bitmap): Int {\r\n                // The cache size will be measured in kilobytes rather than\r\n                // number of items.\r\n                return bitmap.byteCount / 1024\r\n            }\r\n        }\r\n    }\r\n    private fun mStringToURL(string: String): URL? {\r\n        try {\r\n            return URL(string)\r\n        } catch (e: MalformedURLException) {\r\n            e.printStackTrace()\r\n        }\r\n        return null\r\n    }\r\n\r\n    private fun mSaveMediaToStorage(bitmap: Bitmap?) {\r\n        val filename = \"${System.currentTimeMillis()}.jpg\"\r\n        var fos: OutputStream? = null\r\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {\r\n            context.contentResolver?.also { resolver ->\r\n                val contentValues = ContentValues().apply {\r\n                    put(MediaStore.MediaColumns.DISPLAY_NAME, filename)\r\n                    put(MediaStore.MediaColumns.MIME_TYPE, \"image/jpg\")\r\n                    put(MediaStore.MediaColumns.RELATIVE_PATH, Environment.DIRECTORY_PICTURES)\r\n                }\r\n                val imageUri: Uri? =\r\n                    resolver.insert(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, contentValues)\r\n                fos = imageUri?.let { resolver.openOutputStream(it) }\r\n            }\r\n        } else {\r\n            val imagesDir =\r\n                Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_PICTURES)\r\n            val image = File(imagesDir, filename)\r\n            fos = FileOutputStream(image)\r\n        }\r\n        fos?.use {\r\n            bitmap?.compress(Bitmap.CompressFormat.JPEG, 100, it)\r\n            Toast.makeText(context, \"Saved to Gallery\", Toast.LENGTH_SHORT).show()\r\n        }\r\n    }\r\n\r\n    private fun loadBitmap(string: String): Bitmap? {\r\n        val url: URL = mStringToURL(string)!!\r\n        val connection: HttpURLConnection?\r\n        try {\r\n            connection = url.openConnection() as HttpURLConnection\r\n            connection.connect()\r\n            val inputStream: InputStream = connection.inputStream\r\n            val bufferedInputStream = BufferedInputStream(inputStream)\r\n            return BitmapFactory.decodeStream(bufferedInputStream)\r\n        } catch (e: IOException) {\r\n            e.printStackTrace()\r\n            Toast.makeText(context, \"Error\", Toast.LENGTH_LONG).show()\r\n        }\r\n        return null\r\n    }\r\n\r\n    /** Met à jour l'image à la semaine correspondant à l'objet MainActivity.displayedWeekId */\r\n    fun updateImage(ignoreCache: Boolean = false) {\r\n\r\n        // Crée le lien vers l'image\r\n        val spliturl = MainActivity.referenceURL.split(\"&\") as MutableList\r\n        spliturl[MainActivity.idSemaineUrl] = \"idPianoWeek=${MainActivity.displayedWeekId}\"\r\n        val url = spliturl.joinToString(\"&\")\r\n\r\n//        Log.v(\"call\", \"CALLED ${MainActivity.displayedWeekId}\")\r\n        executor.execute {\r\n            val imageBitmap = loadBitmap(url)!!\r\n            val key = \"week${MainActivity.displayedWeekId}\"\r\n            handler.post {\r\n                if (cacheHandler.isExpired() or ignoreCache) {\r\n                    imageView.setImageBitmap(imageBitmap)\r\n                    //TODO ajouter le jour de la semaine\r\n                    cacheHandler.setImage(key, imageBitmap, ignoreCache)\r\n                } else { //TODO à tester\r\n                    Log.d(\"CacheHandler\", cacheHandler.getImage(key).toString())\r\n                    if (cacheHandler.getImage(key) != null) {\r\n                        imageView.setImageBitmap(cacheHandler.getImage(key))\r\n                    } else {\r\n                        updateImage(true)\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /*fun loadBitmap(key: String, imageView: ImageView): Bitmap {\r\n        val imageKey: String = key\r\n\r\n        val bitmap: Bitmap? = getBitmapFromMemCache(imageKey)?.also {\r\n            return it\r\n    }*/\r\n    fun getBitmapFromMemCache(key: String): Bitmap? {\r\n        return memoryCache.get(key)\r\n    }\r\n    fun setBitmapIntoMemCache(key: String, value: Bitmap) {\r\n        synchronized (memoryCache) {\r\n            if (memoryCache.get(key) == null) {\r\n                memoryCache.put(key, value);\r\n                Log.d(\"CacheHandler\", \"saved $key data : $value\")\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/seventeen/edtinp/ImageHandler.kt b/app/src/main/java/com/seventeen/edtinp/ImageHandler.kt
--- a/app/src/main/java/com/seventeen/edtinp/ImageHandler.kt	(revision 841cbd270692e21f649c78520020a7385fb5c8a7)
+++ b/app/src/main/java/com/seventeen/edtinp/ImageHandler.kt	(date 1695480471902)
@@ -10,7 +10,6 @@
 import android.os.Handler
 import android.provider.MediaStore
 import android.util.Log
-import android.util.LruCache
 import android.widget.ImageView
 import android.widget.Toast
 import java.io.BufferedInputStream
@@ -36,29 +35,7 @@
     private val handler: Handler,
     private val cacheHandler: CacheHandler
 ) {
-    private var memoryCache: LruCache<String, Bitmap>
-
-
-    init {
-        // Get max available VM memory, exceeding this amount will throw an
-        // OutOfMemory exception. Stored in kilobytes as LruCache takes an
-        // int in its constructor.
-        val maxMemory = (Runtime.getRuntime().maxMemory() / 1024).toInt()
-
-//        Log.d("CacheHandler", File(context.cacheDir, ""))
-
-        // Use 1/8th of the available memory for this memory cache.
-        val cacheSize = maxMemory / 8
-
-        memoryCache = object : LruCache<String, Bitmap>(cacheSize) {
-
-            override fun sizeOf(key: String, bitmap: Bitmap): Int {
-                // The cache size will be measured in kilobytes rather than
-                // number of items.
-                return bitmap.byteCount / 1024
-            }
-        }
-    }
+    /** @return Retourne un objet URL à partir de l'adresse donnée en paramètre */
     private fun mStringToURL(string: String): URL? {
         try {
             return URL(string)
@@ -94,6 +71,10 @@
         }
     }
 
+
+    /**
+     * Récupère le bitmap à partir d'une url
+     */
     private fun loadBitmap(string: String): Bitmap? {
         val url: URL = mStringToURL(string)!!
         val connection: HttpURLConnection?
@@ -105,7 +86,7 @@
             return BitmapFactory.decodeStream(bufferedInputStream)
         } catch (e: IOException) {
             e.printStackTrace()
-            Toast.makeText(context, "Error", Toast.LENGTH_LONG).show()
+            Toast.makeText(context, "Erreur", Toast.LENGTH_SHORT).show()
         }
         return null
     }
@@ -118,16 +99,17 @@
         spliturl[MainActivity.idSemaineUrl] = "idPianoWeek=${MainActivity.displayedWeekId}"
         val url = spliturl.joinToString("&")
 
-//        Log.v("call", "CALLED ${MainActivity.displayedWeekId}")
         executor.execute {
             val imageBitmap = loadBitmap(url)!!
             val key = "week${MainActivity.displayedWeekId}"
             handler.post {
+                // Ajoute ou non l'image au cache après l'avoir chargée et affichée
                 if (cacheHandler.isExpired() or ignoreCache) {
                     imageView.setImageBitmap(imageBitmap)
-                    //TODO ajouter le jour de la semaine
+                    //TODO ajouter le jour de la semaine pour la péremption
                     cacheHandler.setImage(key, imageBitmap, ignoreCache)
                 } else { //TODO à tester
+                    // Si un cache est disponible, alors c'est l'image du cache qui est chargée
                     Log.d("CacheHandler", cacheHandler.getImage(key).toString())
                     if (cacheHandler.getImage(key) != null) {
                         imageView.setImageBitmap(cacheHandler.getImage(key))
@@ -138,23 +120,5 @@
             }
         }
     }
-
-    /*fun loadBitmap(key: String, imageView: ImageView): Bitmap {
-        val imageKey: String = key
-
-        val bitmap: Bitmap? = getBitmapFromMemCache(imageKey)?.also {
-            return it
-    }*/
-    fun getBitmapFromMemCache(key: String): Bitmap? {
-        return memoryCache.get(key)
-    }
-    fun setBitmapIntoMemCache(key: String, value: Bitmap) {
-        synchronized (memoryCache) {
-            if (memoryCache.get(key) == null) {
-                memoryCache.put(key, value);
-                Log.d("CacheHandler", "saved $key data : $value")
-            }
-        }
-    }
 }
 
Index: app/src/main/java/com/seventeen/edtinp/CacheHandler.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.seventeen.edtinp\r\n\r\nimport android.content.Context\r\nimport android.graphics.Bitmap\r\nimport android.graphics.BitmapFactory\r\nimport android.util.Log\r\nimport android.widget.Toast\r\nimport java.io.File\r\nimport java.io.FileNotFoundException\r\nimport java.io.FileOutputStream\r\nimport java.io.IOException\r\n\r\n\r\nclass CacheHandler(private val context: Context, private val dataHandler: DataHandler) {\r\n    lateinit var cacheFile: File\r\n    init {\r\n        cacheFile = File(context.cacheDir, \"ImageCache\")\r\n//        if (cacheFile.listFiles() != null) { Log.d(\"CacheHandler\", \"Found cache\"); Log.d(\"CacheHandler\", cacheFile.listFiles().toString()) }\r\n//        else { Log.d(\"CacheHandler\", \"No cache found\"); createCache()}\r\n    }\r\n    fun setImage(key: String, value: Bitmap, ignoreCache: Boolean = false) {\r\n        val cacheDir = context.cacheDir\r\n        val file = File(cacheDir, key)\r\n\r\n        /*var previousWeek: Int\r\n        var thirdWeek: Int\r\n\r\n        if (dataHandler.getCurrentWeekId() > 0) {\r\n            previousWeek = dataHandler.getCurrentWeekId()-1\r\n        } else { previousWeek = 0}\r\n\r\n        if (dataHandler.getCurrentWeekId()+2 < 51) {\r\n            thirdWeek = dataHandler.getCurrentWeekId()+2\r\n        } else { thirdWeek = 51 }*/\r\n\r\n//        if (MainActivity.displayedWeekId in (previousWeek..thirdWeek)) {\r\n        if (MainActivity.displayedWeekId == dataHandler.getCurrentWeekId()) {\r\n            if ((getImage(key) == null) or (ignoreCache)) {\r\n                try {\r\n                    val outputStream = FileOutputStream(file)\r\n                    value.compress(Bitmap.CompressFormat.PNG, 100, outputStream)\r\n                    outputStream.flush()\r\n                    outputStream.close()\r\n                    Log.d(\"CacheHandler\", \"Saved to cache\")\r\n                    if (ignoreCache) {\r\n                        Toast.makeText(context, \"Mise à jour réussie\", Toast.LENGTH_SHORT).show()\r\n                    }\r\n                } catch (e: Exception) {\r\n                    e.printStackTrace()\r\n                }\r\n            }\r\n        }\r\n    }\r\n    fun getImage(key: String): Bitmap? {\r\n        val cacheDir = context.cacheDir\r\n        val file = File(cacheDir, key)\r\n\r\n        if (file.exists()) {\r\n            return BitmapFactory.decodeFile(file.absolutePath)\r\n        } else {\r\n            return null\r\n        }\r\n    }\r\n\r\n    fun isExpired(): Boolean {\r\n        return true\r\n    }\r\n\r\n    private fun createCache() {\r\n        File.createTempFile(\"ImageCache\", null, context.cacheDir)\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/seventeen/edtinp/CacheHandler.kt b/app/src/main/java/com/seventeen/edtinp/CacheHandler.kt
--- a/app/src/main/java/com/seventeen/edtinp/CacheHandler.kt	(revision 841cbd270692e21f649c78520020a7385fb5c8a7)
+++ b/app/src/main/java/com/seventeen/edtinp/CacheHandler.kt	(date 1695480471912)
@@ -6,18 +6,20 @@
 import android.util.Log
 import android.widget.Toast
 import java.io.File
-import java.io.FileNotFoundException
 import java.io.FileOutputStream
-import java.io.IOException
 
-
+/**
+ * Gestionnaire de cache
+ * @param dataHandler DataHandler unique
+ */
 class CacheHandler(private val context: Context, private val dataHandler: DataHandler) {
-    lateinit var cacheFile: File
-    init {
-        cacheFile = File(context.cacheDir, "ImageCache")
-//        if (cacheFile.listFiles() != null) { Log.d("CacheHandler", "Found cache"); Log.d("CacheHandler", cacheFile.listFiles().toString()) }
-//        else { Log.d("CacheHandler", "No cache found"); createCache()}
-    }
+
+    /**
+     * Ajoute un bitmap au cache
+     * @param key Nom du bitmap stocké
+     * @param value Contenu du bitmap
+     * @param ignoreCache Booléen obligeant à invalider le cache
+     */
     fun setImage(key: String, value: Bitmap, ignoreCache: Boolean = false) {
         val cacheDir = context.cacheDir
         val file = File(cacheDir, key)
@@ -51,21 +53,29 @@
             }
         }
     }
+
+    /**
+     * Récupère un bitmap en cache
+     * @param key Nom du bitmap à récupérer
+     */
     fun getImage(key: String): Bitmap? {
         val cacheDir = context.cacheDir
         val file = File(cacheDir, key)
 
-        if (file.exists()) {
-            return BitmapFactory.decodeFile(file.absolutePath)
+
+        return if (file.exists()) {
+            BitmapFactory.decodeFile(file.absolutePath)
         } else {
-            return null
+            null
         }
     }
 
+    /** Vérifie si le bitmap en cache n'est pas trop vieux */
     fun isExpired(): Boolean {
         return true
     }
 
+    /** Crée un fichier cache */
     private fun createCache() {
         File.createTempFile("ImageCache", null, context.cacheDir)
     }
Index: app/src/main/java/com/seventeen/edtinp/DatePicker.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.seventeen.edtinp\r\n\r\nimport android.app.Dialog\r\nimport android.os.Bundle\r\nimport android.util.Log\r\nimport android.view.View\r\nimport android.widget.CalendarView\r\nimport androidx.appcompat.app.AlertDialog\r\nimport androidx.fragment.app.DialogFragment\r\nimport androidx.fragment.app.FragmentActivity\r\nimport java.util.Calendar\r\n\r\nclass DatePicker(private val imageHandler: ImageHandler) :\r\n    DialogFragment(R.layout.date_dialog_fragment) {\r\n\r\n    override fun onCreateDialog(savedInstanceState: Bundle?): Dialog {\r\n        val inflater = activity?.layoutInflater\r\n        val view: View = inflater!!.inflate(R.layout.date_picker_fragment, null)\r\n        val datePickerView = view.findViewById<CalendarView>(R.id.date_picker)\r\n\r\n        datePickerView.setOnDateChangeListener { _, year, month, day ->\r\n            val c = Calendar.getInstance()\r\n            c.set(year, month, day)\r\n\r\n            var selectedWeekNumber = c.get(Calendar.WEEK_OF_YEAR)\r\n            if ((c.get(Calendar.DAY_OF_WEEK) == Calendar.SATURDAY) or (c.get(Calendar.DAY_OF_WEEK) == Calendar.SUNDAY)) {\r\n                selectedWeekNumber += 1\r\n            }\r\n            val selectedWeekId: Int\r\n            if (selectedWeekNumber < 32) {\r\n                selectedWeekId = selectedWeekNumber + 20\r\n            } else {\r\n                selectedWeekId = selectedWeekNumber - 32\r\n            }\r\n\r\n            //TODO cleanup\r\n            //TODO restreindre la sélection aux semaines valides\r\n\r\n            /*Toast.makeText(\r\n                inflater.context,\r\n                \"Selected Date = $strFormattedSelectedDate\",\r\n                Toast.LENGTH_SHORT\r\n            ).show()*/\r\n            MainActivity().onDatePass(selectedWeekId, activity)\r\n        }\r\n\r\n        val builder: AlertDialog.Builder = AlertDialog.Builder(layoutInflater.context)\r\n        builder.setTitle(\"Choisissez une date\")\r\n        builder.setView(view)\r\n\r\n        builder.setPositiveButton(\"OK\") { dialog, which ->\r\n\r\n            // on success\r\n            Log.v(\"DatePicker\", MainActivity.selectedWeekId.toString())\r\n\r\n            if (MainActivity.selectedWeekId != MainActivity.displayedWeekId) {\r\n                MainActivity.displayedWeekId = MainActivity.selectedWeekId\r\n                // Met à jour l'image\r\n                imageHandler.updateImage()\r\n            }\r\n            activity?.supportFragmentManager?.beginTransaction()?.remove(this)?.commit()\r\n        }\r\n\r\n\r\n        builder.setNegativeButton(\"Annuler\") { dialog, which -> dialog.dismiss() }\r\n\r\n        return builder.create()\r\n    }\r\n\r\n    override fun onStart() {\r\n        super.onStart()\r\n        val d = dialog as AlertDialog?\r\n        if (d != null && MainActivity.isNavigationRestricted) {\r\n            val positiveButton = d.getButton(Dialog.BUTTON_POSITIVE)\r\n            positiveButton.setEnabled(false)\r\n        }\r\n    }\r\n\r\n    interface OnDatePass {\r\n        fun onDatePass(weekId: Int, activity: FragmentActivity?)\r\n    }\r\n\r\n    companion object Const {\r\n        const val TAG = \"DatePickerFragment\"\r\n    }\r\n\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/seventeen/edtinp/DatePicker.kt b/app/src/main/java/com/seventeen/edtinp/DatePicker.kt
--- a/app/src/main/java/com/seventeen/edtinp/DatePicker.kt	(revision 841cbd270692e21f649c78520020a7385fb5c8a7)
+++ b/app/src/main/java/com/seventeen/edtinp/DatePicker.kt	(date 1695480471920)
@@ -26,14 +26,11 @@
             if ((c.get(Calendar.DAY_OF_WEEK) == Calendar.SATURDAY) or (c.get(Calendar.DAY_OF_WEEK) == Calendar.SUNDAY)) {
                 selectedWeekNumber += 1
             }
-            val selectedWeekId: Int
-            if (selectedWeekNumber < 32) {
-                selectedWeekId = selectedWeekNumber + 20
+            val selectedWeekId: Int = if (selectedWeekNumber < 32) {
+                selectedWeekNumber + 20
             } else {
-                selectedWeekId = selectedWeekNumber - 32
+                selectedWeekNumber - 32
             }
-
-            //TODO cleanup
             //TODO restreindre la sélection aux semaines valides
 
             /*Toast.makeText(
@@ -48,11 +45,8 @@
         builder.setTitle("Choisissez une date")
         builder.setView(view)
 
-        builder.setPositiveButton("OK") { dialog, which ->
-
-            // on success
+        builder.setPositiveButton("OK") { _, _ ->
             Log.v("DatePicker", MainActivity.selectedWeekId.toString())
-
             if (MainActivity.selectedWeekId != MainActivity.displayedWeekId) {
                 MainActivity.displayedWeekId = MainActivity.selectedWeekId
                 // Met à jour l'image
@@ -61,18 +55,18 @@
             activity?.supportFragmentManager?.beginTransaction()?.remove(this)?.commit()
         }
 
-
-        builder.setNegativeButton("Annuler") { dialog, which -> dialog.dismiss() }
+        builder.setNegativeButton("Annuler") { dialog, _ -> dialog.dismiss() }
 
         return builder.create()
     }
 
+    /** Si utilisation en navigation restreinte, alors le bouton de validation est désactivé */
     override fun onStart() {
         super.onStart()
         val d = dialog as AlertDialog?
         if (d != null && MainActivity.isNavigationRestricted) {
             val positiveButton = d.getButton(Dialog.BUTTON_POSITIVE)
-            positiveButton.setEnabled(false)
+            positiveButton.isEnabled = false
         }
     }
 
